# -*- coding: utf-8 -*-
"""Untitled13.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mzBFbEt6PmYzQJswEC6_7-cVYJMY_GOG
"""

#Fuzzy Logic–Based Sentiment Classifier
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import skfuzzy as fuzz
import nltk
from nltk.sentiment import SentimentIntensityAnalyzer
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Input
from tensorflow.keras.utils import to_categorical
nltk.download('vader_lexicon')

data = {
    "text": [
        "I absolutely loved this movie! It was fantastic.",
        "The product is terrible and broke after one day.",
        "It was an average experience, nothing special.",
        "I'm not sure if I liked it or not.",
        "Such a wonderful time with great friends.",
        "Worst decision ever, total waste of money.",
        "It’s okay, not great but not bad either.",
        "Amazing service and super friendly staff!",
        "Completely disappointed with the quality.",
        "This meal was delicious, I’ll come again!"
    ],
    "label": [
        "positive", "negative", "neutral", "neutral",
        "positive", "negative", "neutral", "positive",
        "negative", "positive"
    ]
}

df = pd.DataFrame(data)
print(df.head())


sia = SentimentIntensityAnalyzer()
df["polarity"] = df["text"].apply(lambda x: sia.polarity_scores(x)["compound"])
df.head()

# Define fuzzy sets for sentiment polarity (-1 to 1)
x_sentiment = np.linspace(-1, 1, 100)
negative = fuzz.trimf(x_sentiment, [-1, -1, 0])
neutral  = fuzz.trimf(x_sentiment, [-0.2, 0, 0.2])
positive = fuzz.trimf(x_sentiment, [0, 1, 1])

# Visualize membership functions
plt.figure(figsize=(8, 4))
plt.plot(x_sentiment, negative, 'r', label='Negative')
plt.plot(x_sentiment, neutral, 'g', label='Neutral')
plt.plot(x_sentiment, positive, 'b', label='Positive')
plt.title("Fuzzy Sentiment Membership Functions")
plt.xlabel("Sentiment Polarity")
plt.ylabel("Membership Degree")
plt.legend()
plt.grid(True)
plt.show()

def fuzzy_features(score):
    neg = fuzz.interp_membership(x_sentiment, negative, score)
    neu = fuzz.interp_membership(x_sentiment, neutral, score)
    pos = fuzz.interp_membership(x_sentiment, positive, score)
    return [neg, neu, pos]

fuzzy_feats = np.array([fuzzy_features(s) for s in df["polarity"]])
df[["fuzzy_neg", "fuzzy_neu", "fuzzy_pos"]] = fuzzy_feats
df.head()

vectorizer = TfidfVectorizer(max_features=100)
X_tfidf = vectorizer.fit_transform(df["text"]).toarray()
X_combined = np.hstack([X_tfidf, fuzzy_feats])

#Encode labels
le = LabelEncoder()
y = le.fit_transform(df["label"])
y_cat = to_categorical(y)

#Split data
X_train, X_test, y_train, y_test = train_test_split(X_combined, y_cat, test_size=0.2, random_state=42)

model = Sequential([
    Input(shape=(X_combined.shape[1],)),
    Dense(64, activation='relu'),
    Dropout(0.3),
    Dense(3, activation='softmax')
])

model.compile(optimizer='adam', loss='categorical_crossentropy', metrics=['accuracy'])
model.summary()

history=model.fit(X_train, y_train, validation_split=0.2, epochs=20, batch_size=4, verbose=1)

loss, acc = model.evaluate(X_test, y_test)
print(f"\nTest Accuracy: {acc*100:.2f}%")

plt.figure(figsize=(8,4))
plt.plot(history.history['accuracy'], label='train_acc')
plt.plot(history.history['val_accuracy'], label='val_acc')
plt.title("Model Accuracy")
plt.xlabel("Epoch")
plt.ylabel("Accuracy")
plt.legend()
plt.show()

sample_texts = [
    "I hate this product, it’s awful.",
    "This was a fantastic experience!",
    "Not bad, could be better though."
]

sample_scores = [sia.polarity_scores(t)["compound"] for t in sample_texts]
sample_fuzzy = np.array([fuzzy_features(s) for s in sample_scores])
sample_tfidf = vectorizer.transform(sample_texts).toarray()
sample_combined = np.hstack([sample_tfidf, sample_fuzzy])
preds = model.predict(sample_combined)
pred_labels = le.inverse_transform(np.argmax(preds, axis=1))
for t, p in zip(sample_texts, pred_labels):
    print(f" {t}\nPredicted Sentiment: {p}\n")

!pip install scikit-fuzzy

Y